#!/usr/bin/env python3

import subprocess
import signal
import configparser
import os

import Xlib
import Xlib.display
from gi.repository import Gtk, Gdk, GObject, GdkX11
from gi.overrides import keysyms

##
#gdk helper functions
##

class GdkEvents:
	'''
	event filters are not used due to this bug:
		https://bugzilla.gnome.org/show_bug.cgi?id=687898
	'''
	def __init__(self):
		#use a dict instead of a list so that id's can be removed properly (list indices can change if a previous event listener is removed)
		self.event_listeners = {}
		Gdk.Event.handler_set(self.event_handler, None)

	def event_handler(self, event, data):
		#make a copy to avoid errors if the dict changes size
		for func, func_args, func_kwargs in list(self.event_listeners.values()):
			func(event, *func_args, **func_kwargs)
		Gtk.main_do_event(event)

	def add_event_listener(self, func, func_args=None, func_kwargs=None):
		if func_args is None:
			func_args = ()
		if func_kwargs is None:
			func_kwargs = {}
		listener_id = len(self.event_listeners)
		self.event_listeners[listener_id] = (func, func_args, func_kwargs)
		return listener_id

	def remove_event_listener(self, index):
		'''
		args:
			index:	functions are not used due to additional introduction of a map structure
		'''
		del self.event_listeners[index]

gdk_events = GdkEvents()

##
#gtk helper classes
##

class ClosableTabLabel(Gtk.Box):
	__gsignals__ = {
		"close_clicked": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE, ()),
		"label_edit_focus": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE, ()),
		"label_edit_blur": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE, ()),
		"label_edit_submit": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE, ()),
	}

	def __init__(self, label_text):
		super().__init__()
		self.set_orientation(Gtk.Orientation.HORIZONTAL)

		#label
		label_event_box = Gtk.EventBox()
		self.label = Gtk.Label(label_text)
		label_event_box.add(self.label)
		label_event_box.connect('button-press-event', self.on_label_button_press)
		self.pack_start(label_event_box, True, True, 0)

		self.label_entry = Gtk.Entry()
		self.label_entry.connect('key-press-event', self.on_label_entry_key_press)
		self.label_entry.connect('focus-out-event', self.on_label_entry_focus_out)
		self.label_entry.connect('changed', self.on_label_entry_changed)
		self.pack_start(self.label_entry, True, True, 0)

		#close button
		button = Gtk.Button()
		button.set_relief(Gtk.ReliefStyle.NONE)
		button.set_focus_on_click(False)
		button.add(Gtk.Image.new_from_stock(Gtk.STOCK_CLOSE, Gtk.IconSize.MENU))
		button.connect('clicked', self.on_close_click)
		data =  \
			'.button {' \
				'-GtkButton-default-border : 0px;' \
				'-GtkButton-default-outside-border : 0px;' \
				'-GtkButton-inner-border: 0px;' \
				'-GtkWidget-focus-line-width : 0px;' \
				'-GtkWidget-focus-padding : 0px;' \
				'padding: 0px;' \
			'}'
		provider = Gtk.CssProvider()
		provider.load_from_data(data.encode())
		#GTK_STYLE_PROVIDER_PRIORITY_APPLICATION = 600
		button.get_style_context().add_provider(provider, 600)
		self.button = button
		self.pack_start(button, False, False, 0)

		#show all
		self.show_all()
		self.label_entry.hide()

	def get_text(self):
		return self.label.get_text()

	def set_text(self, label_text):
		self.label.set_text(label_text)

	def on_close_click(self, button, data=None):
		self.emit('close_clicked')

	def label_edit_focus(self):
		self.label.hide()
		self.label_entry.show()
		self.label_entry.grab_focus()
		label_text = self.label.get_text()
		self.label_entry.set_width_chars(len(label_text))
		self.label_entry.set_text(label_text)
		#select all text
		self.label_entry.emit('move-cursor', 1, len(label_text), True)
		self.emit('label_edit_focus')

	def label_edit_submit(self):
		label_text = self.label_entry.get_text()
		self.label.set_text(label_text)
		self.emit('label_edit_submit')
		self.label_edit_blur()

	def label_edit_blur(self):
		self.label_entry.hide()
		self.label.show()
		self.emit('label_edit_blur')

	def on_label_button_press(self, event_box, event, data=None):
		'''
		edit label on double click
		'''
		if event.type==Gdk.EventType._2BUTTON_PRESS:
			self.label_edit_focus()

	def on_label_entry_key_press(self, label_entry, event, data=None):
		'''
		restore label after enter is pressed
		'''
		if event.keyval==keysyms.Return:
			#enter key press
			self.label_edit_submit()
		elif event.keyval==keysyms.Escape:
			#enter key press
			self.label_edit_blur()

	def on_label_entry_focus_out(self, label_entry, event, data=None):
		'''
		restore label after focus out
		'''
		self.label_edit_blur()

	def on_label_entry_changed(self, label_entry, data=None):
		'''
		adapt label size
		'''
		label_text = self.label_entry.get_text()
		self.label_entry.set_width_chars(len(label_text))

##
#urxvt tabs
##

class UrxvtTabbedWindow(Gtk.Window):
	'''
	Wrapper around urxvt which adds tabs
	the Gtk2::URxvt perl module doesn't seem to be available yet
	'''

	def __init__(self):
		super().__init__(title='urxvt')

		vbox = Gtk.VBox()
		self.add(vbox)

		#tabs container
		notebook = Gtk.Notebook()
		notebook.set_can_focus(False)
		notebook.set_scrollable(True)
		vbox.pack_start(notebook, True, True, 0)
		self.notebook = notebook

		#new tab button
		new_tab_button = Gtk.Button()
		new_tab_button.set_relief(Gtk.ReliefStyle.NONE)
		new_tab_button.add(Gtk.Image.new_from_stock(Gtk.STOCK_ADD, Gtk.IconSize.MENU))
		new_tab_button.connect('clicked', self.on_new_tab_click)
		new_tab_button.show_all()
		notebook.set_action_widget(new_tab_button, Gtk.PackType.END)
		self.connect('delete_event', self.on_delete_event)

		#add new tab (otherwise the notebook won't appear)
		self.add_new_terminal()

		#set window icon
		icon_info = Gtk.IconTheme.get_default().lookup_icon('terminal', 48, 0)
		if icon_info:
			self.set_icon(icon_info.load_icon())

	def add_new_terminal(self):
		notebook = self.notebook
		urxvt_tab = UrxvtTab()
		notebook.append_page(urxvt_tab.rxvt_socket, urxvt_tab.label)
		notebook.set_tab_reorderable(urxvt_tab.rxvt_socket, 1)
		urxvt_tab.rxvt_socket.show_all()
		notebook.set_current_page(notebook.page_num(urxvt_tab.rxvt_socket))

	def on_new_tab_click(self, widget):
		self.add_new_terminal()

	def on_delete_event(self, widget, data):
		children = self.notebook.get_children()
		num_tabs = len(children)
		if num_tabs <= 1:
			#close window if there's only a single tab
			Gtk.main_quit()
		else:
			#ask the user to close all tabs or not
			dialog = Gtk.MessageDialog(
				flags=Gtk.DialogFlags.MODAL,
				type=Gtk.MessageType.QUESTION,
				message_format='You are about to close {} tabs. Are you sure you want to continue?'.format(num_tabs)
			)
			dialog.add_button('Close window', Gtk.ResponseType.OK)
			dialog.add_button('Cancel', Gtk.ResponseType.CANCEL)
			response_code = dialog.run()
			if response_code == Gtk.ResponseType.OK:
				Gtk.main_quit()
			else:
				dialog.destroy()
				return True


class UrxvtTab:
	RXVT_BASENAME = 'urxvt'

	def __init__(self, title='urxvt'):
		label = ClosableTabLabel(title)
		label.connect('close_clicked', self.on_new_tab_close_click)
		label.connect('label_edit_submit', self.on_label_edit_submit)
		label.connect('label_edit_blur', self.on_label_edit_blur)
		self.label = label
		#embedded terminal
		rxvt_socket = Gtk.Socket()
		self.rxvt_socket = rxvt_socket
		rxvt_socket.set_can_focus(True)
		#pygobject has some strange bug where if self is directory used then self fields won't exist
		rxvt_socket.connect_after('realize', lambda *args, **kwargs: self.on_realize(*args, **kwargs))
		rxvt_socket.connect_after('plug_added', lambda *args, **kwargs: self.on_plug_added(*args, **kwargs))
		rxvt_socket.connect_after('map_event', lambda *args, **kwargs: self.on_map_event(*args, **kwargs))
		self.event_listener_id = None
		self.plugged = None
		self.terminal_process = None
		#tab labels
		self.shell_title = title
		self.has_custom_title = False

	def update_tab_geometry_hints(self):
		'''
		copy the WM_NORMAL_HINTS properties of rxvt window to the rxvt tab so it stays within the rxvt resizing requirements
		resizing might not be smooth anymore if this is called
		'''
		rxvt_socket = self.rxvt_socket
		display = Xlib.display.Display()
		xlib_window = display.create_resource_object('window', self.plugged.get_xid())
		hints = xlib_window.get_wm_normal_hints()
		geometry = Gdk.Geometry()
		geometry.base_width = hints.base_width
		geometry.base_height = hints.base_height
		geometry.width_inc = hints.width_inc
		geometry.height_inc = hints.height_inc
		geom_mask = Gdk.WindowHints(0)
		geom_mask |= Gdk.WindowHints.BASE_SIZE
		geom_mask |= Gdk.WindowHints.RESIZE_INC
		rxvt_socket.get_toplevel().set_geometry_hints(rxvt_socket, geometry, geom_mask)

	def on_realize(self, rxvt_socket):
		'''
		creates a urxvt instance and embed it in widget
		'''
		xid = rxvt_socket.get_window().get_xid()
		self.terminal_process = subprocess.Popen([self.RXVT_BASENAME, '-embed', str(xid)])
		return False

	def on_map_event(self, rxvt_socket, event):
		rxvt_socket.grab_focus()
		return False

	def on_plug_added(self, rxvt_socket):
		'''
		runs when the urxvt embedded process attaches a plug to the socket specified by the xid
			(passed to it as a command-line argument)
		'''
		plugged = rxvt_socket.get_plug_window()
		if plugged is None:
			return
		self.plugged = plugged
		self.update_tab_geometry_hints()
		#listen to gdk property change events
		plugged.set_events(plugged.get_events()|Gdk.EventMask.PROPERTY_CHANGE_MASK)
		#urxvt only uses x.org, so only gdk events can be used
		self.event_listener_id = gdk_events.add_event_listener(self.on_gdk_event)
		return False

	def shell_set_title(self, title):
		if not self.has_custom_title:
			self.label.set_text(title)

	def user_set_title(self, title):
		#only use the user specified label if it isn't empty
		if title:
			self.has_custom_title = True
			self.label.set_text(title)
		else:
			self.has_custom_title = False
			self.label.set_text(self.shell_title)

	def on_gdk_event(self, event):
		'''
		events are also created when the urxvt plugged window closes,
			this handler disconnects itself when it recieves the event
		'''
		try:
			if event.type == Gdk.EventType.CONFIGURE:
				self.update_tab_geometry_hints()
			elif event.type == Gdk.EventType.PROPERTY_NOTIFY:
				if event.state == Gdk.PropertyState.NEW_VALUE:
					if event.atom.name() == '_NET_WM_NAME':
						#window name change event, set tab title
						display = Xlib.display.Display()
						xlib_window = display.create_resource_object('window', self.plugged.get_xid())
						title = xlib_window.get_wm_name()
						self.shell_title = title
						self.shell_set_title(title)
		except Xlib.error.BadWindow:
			#the plug window has now closed itself (there are no events indicating this, so catch the exception instead)
			gdk_events.remove_event_listener(self.event_listener_id)

	def on_label_edit_blur(self, label):
		self.rxvt_socket.grab_focus()

	def on_label_edit_submit(self, label):
		self.user_set_title(self.label.get_text())

	def close(self):
		#this detaches the gdk event listener as well, see docs for on_gdk_event()
		self.terminal_process.send_signal(signal.SIGINT)
		#call wait() so there's no defunct process
		self.terminal_process.wait()

	def on_new_tab_close_click(self, widget):
		self.close()


def main():
	config = configparser.ConfigParser()
	config.read(os.path.expanduser('~/.urxvt_tabbed/urxvt_tabbed.conf'))
	tabbed_window = UrxvtTabbedWindow()
	tabbed_window.maximize()
	tabbed_window.show_all()
	Gtk.main()

if __name__=='__main__':
	main()
